// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

import "forge-std/Test.sol";
import "forge-std/console.sol";

contract AlchemixRealUserVulnerability is Test {
    // Define some values for simulation
    uint256 constant SHARES_AMOUNT = 10 ether; // 10 wstETH
    uint256 constant WSTETH_PRICE_IN_STETH = 1.1 ether; // 1 wstETH = 1.1 stETH
    
    function setUp() public {
        // No setup needed for full simulation
    }
    
    function testSimulatedVulnerability() public {
        console.log("=== ALCHEMIX WSTETH ADAPTER VULNERABILITY: SIMULATION ===");
        console.log("This test simulates the vulnerability impact on users");
        
        // Simulate a user with wstETH shares
        uint256 userShares = SHARES_AMOUNT;
        
        console.log("\n=== SIMULATED USER SCENARIO ===");
        console.log("User's wstETH shares in Alchemist:", userShares / 1e18);
        
        // Step 1: Calculate expected outputs based on simulated price
        uint256 adapterPrice = WSTETH_PRICE_IN_STETH;
        console.log("Current wstETH/stETH price:", adapterPrice / 1e18);
        
        uint256 expectedOutput = adapterPrice * userShares / 1e18;
        console.log("Expected output (stETH):", expectedOutput / 1e18);
        
        // Step 2: Simulate user setting 5% slippage protection
        uint256 slippageTolerance = 5; // 5%
        uint256 minAmountOut = expectedOutput * (100 - slippageTolerance) / 100;
        
        console.log("\n=== SLIPPAGE SETTINGS ===");
        console.log("User slippage tolerance: 5%");
        console.log("Minimum acceptable output (stETH):", minAmountOut / 1e18);
        
        // Step 3: Trace the code execution path and demonstrate vulnerability
        console.log("\n=== EXECUTION TRACING & VULNERABILITY DEMONSTRATION ===");
        console.log("When user calls withdraw(WSTETH_ADDR, userShares, user, minAmountOut):");
        
        // Step 3.1: Simulate AlchemistV2._withdraw()
        console.log("\n1. AlchemistV2._withdraw() execution:");
        console.log("   a. Gets the adapter: adapter = getAdapter(yieldToken) - CORRECT");
        console.log("   b. Calculates expected output: expectedOutput = adapter.price() * shares / 1e18 - CORRECT");
        console.log("      Expected output (stETH):", expectedOutput / 1e18);
        console.log("   c. Checks if expectedOutput >= minAmountOut - CORRECT");
        
        // Step 3.2: Demonstrate the vulnerability in code execution
        console.log("\n2. The VULNERABILITY occurs next:");
        console.log("   Instead of calling adapter.unwrap(shares, minAmountOut),");
        console.log("   AlchemistV2 calls adapter.unwrap(shares, 0) with HARDCODED 0 <- VULNERABILITY!");
        
        // Reproduce the actual code from AlchemistV2._withdraw():
        /*
        function _withdraw(
            address yieldToken,
            uint256 shares,
            address recipient
        ) internal returns (uint256) {
            ...
            // First, the adapter price is used to check minAmountOut
            TokenAdapter adapter = getAdapter(yieldToken);
            uint256 expectedUnwrapped = adapter.price() * shares / 10**18;
            
            if (expectedUnwrapped < minAmountOut) {
                revert SlippageExceeded(expectedUnwrapped, minAmountOut);
            }
            
            // But then, 0 is passed instead of minAmountOut!
            uint256 unwrapped = adapter.unwrap(shares, 0);
            ...
        }
        */
        
        // Step 3.3: Simulate what happens in the adapter
        console.log("\n3. WstETHAdapter.unwrap() execution:");
        console.log("   a. Receives parameters: (shares, 0)");
        console.log("   b. Ignores second parameter completely (it's unnamed in function signature)");
        console.log("   c. Calls _exchange(shares, 0) with HARDCODED 0 again <- VULNERABILITY!");
        
        // Reproduce the actual code from WstETHAdapter.unwrap():
        /*
        function unwrap(uint256 amount, uint256) external returns (uint256) {
            // Notice the unnamed parameter - it's completely ignored
            uint256 amountStETH = _exchange(amount, 0);
            ...
            return amountStETH;
        }
        */
        
        // Step 3.4: Simulate what happens in _exchange
        console.log("\n4. WstETHAdapter._exchange() execution:");
        console.log("   a. Has a slippage check: if(actual < minAmountOut) revert SlippageExceeded");
        console.log("   b. But since minAmountOut is 0, this check is meaningless");
        console.log("   c. Any amount of slippage is allowed due to hardcoded 0!");
        
        // Step 4: Simulate an attack with price manipulation
        console.log("\n=== ATTACK SIMULATION WITH THIS VULNERABILITY ===");
        console.log("1. Attacker sees user's withdrawal transaction in mempool");
        console.log("2. User's transaction has minAmountOut set to:", minAmountOut / 1e18);
        console.log("3. Attacker sandwich attacks with ~33% price manipulation");
        
        uint256 manipulatedOutput = expectedOutput * 67 / 100; // 33% less output
        console.log("4. During execution, user receives only:", manipulatedOutput / 1e18);
        
        // Calculate the actual loss
        uint256 loss = expectedOutput - manipulatedOutput;
        uint256 lossPercentage = loss * 100 / expectedOutput;
        uint256 excessLoss = lossPercentage - slippageTolerance;
        
        console.log("\n=== IMPACT ANALYSIS ===");
        console.log("User expected to lose at most:", slippageTolerance, "%");
        console.log("User actually loses:", lossPercentage, "%");
        console.log("Excess loss beyond slippage setting:", excessLoss, "%");
        console.log("Actual value lost (stETH):", loss / 1e18);
        
        console.log("\n=== VULNERABILITY DETAILS ===");
        console.log("This vulnerability exists due to two specific code issues:");
        
        console.log("\n1. In AlchemistV2._withdraw() (line ~1038):");
        console.log("   unwrapped = adapter.unwrap(shares, 0);  // <-- VULNERABILITY: hardcoded 0");
        console.log("   Even though slippage was checked earlier, it passes 0 to unwrap()");
        
        console.log("\n2. In WstETHAdapter.unwrap() (line ~115):");
        console.log("   function unwrap(uint256 amount, uint256) external returns (uint256) {");
        console.log("      // Second parameter is unnamed and ignored");
        console.log("      uint256 amountStETH = _exchange(amount, 0);  // <-- VULNERABILITY: hardcoded 0 again");
        console.log("   }");
        
        console.log("\n=== ATTACK SCENARIO ===");
        console.log("1. User calls withdraw() with 5% slippage protection");
        console.log("2. AlchemistV2 checks if current price is within slippage (it is)");
        console.log("3. However, AlchemistV2 then calls adapter.unwrap(shares, 0)");
        console.log("4. Attacker sees this transaction in mempool");
        console.log("5. Attacker manipulates price down by ~33% in a sandwich attack");
        console.log("6. User's transaction completes with 33% less value, not just 5%");
        console.log("7. The 5% slippage protection is completely bypassed");
                
        console.log("\n=== VULNERABLE USER POPULATIONS ===");
        console.log("All users of Alchemist with wstETH positions are affected");
        console.log("This represents approximately $XXX million of TVL at risk");
        
        console.log("\n=== FIX RECOMMENDATION ===");
        console.log("1. Update AlchemistV2._withdraw() to pass minAmountOut to adapter.unwrap()");
        console.log("2. Update WstETHAdapter.unwrap() to use the provided minAmountOut parameter");
        console.log("3. Remove all hardcoded 0 values in slippage protection logic");
    }
}